% Adam Czajka, Zhaoyuan Fang, Kevin W. Bowyer, "Iris Presentation Attack 
% Detection Based on Photometric Stereo Features," IEEE Winter Conference 
% on Applications of Computer Vision (WACV), Waikoloa Village, Hawaii, 2019
% (supplementary materials)
% -------------------------------------------------------------------------
% Version 1.0, November 16, 2018

function [norm_map, variation] = PhotoStereo(img_name, slant, tilt)

%% Image Parameters

% Intialize image & mask cell arrays
img_num = 2;
img = cell(img_num,1);
mask = cell(img_num,1);
mask_morph = cell(img_num,1);

% Iris center position
iris_pos = cell(img_num,1);
% Iris border distance from center: left, up, right, down
iris_hw = cell(img_num,1);
% Iris radius
iris_radius = cell(img_num,1);
% Internal radius (for larger pupil removing)
iris_radius_internal = cell(img_num,1);
% Ratio of radius to exclude (for larger pupil removing)
iris_pct = 0.5;

% Image width and height
img_width = 256;
img_height = 256;

%% Image Preprocessing

for ctr = 1:img_num
    % Iris border distance from center: left, up, right, down
    % Used for segmentation later
    iris_hw{ctr} = zeros(4,1);
    
    % Read image from current folder
    img_ctr = imread([img_name,num2str(ctr),'.tiff']);
    img_ctr = img_ctr(:,:,1);
    img{ctr} = img_ctr;
    
    % Remove linear trend before cropping (does not work very well)
    % img{ctr} = remove2Dtrend(double(img{ctr}));
    
    % Get mask from current folder
    % Mask is generated by OSIRIS v4.1
    mask_ctr = imread([img_name,num2str(ctr),'_mask.bmp']);
    mask{ctr} = double(mask_ctr == 255);
    
    % Read the center of the iris
    border_ctr = dlmread([img_name,num2str(ctr),'_para.txt']);
    
    % Read the points that form the border of the iris
    % Calculate iris center position: average coordinates of border points
    iris_pnum = border_ctr(2,1);
    xtot = 0;
    ytot = 0;
    for k = 1:iris_pnum
        xtot = xtot + border_ctr(4,k*3-2);
        ytot = ytot + border_ctr(4,k*3-1);
    end
    iris_cx = round(xtot/iris_pnum);
    iris_cy = round(ytot/iris_pnum);
    iris_pos{ctr} = [iris_cx;iris_cy];
    
    % Get the largest box of iris from border points
    iris_pts = reshape(border_ctr(4, :), [3, iris_pnum]);
    % Left distance
    iris_hw{ctr}(1) = max(max(iris_cx - iris_pts(1, :)), iris_hw{ctr}(1));
    % Down distance
    iris_hw{ctr}(2) = max(max(iris_pts(2, :) - iris_cy), iris_hw{ctr}(2));
    % Right distance
    iris_hw{ctr}(3) = max(max(iris_pts(1, :) - iris_cx), iris_hw{ctr}(3));
    % Up distance
    iris_hw{ctr}(4) = max(max(iris_cy - iris_pts(2, :)), iris_hw{ctr}(4));
    
    % Calculate the iris radius and the internal radius
    iris_radius{ctr} = max(iris_hw{ctr}(2) + iris_hw{ctr}(4), iris_hw{ctr}(3) + iris_hw{ctr}(1)) / 2;
    iris_radius_internal{ctr} = floor (iris_radius{ctr} * iris_pct);
    
    % Copy mask for morphological operations later
    mask_morph{ctr} = mask{ctr};
    
    % Larger pupil removing
    for pixh = iris_pos{ctr}(2) - iris_radius_internal{ctr} : iris_pos{ctr}(2) + iris_radius_internal{ctr}
        for pixw = iris_pos{ctr}(1) - iris_radius_internal{ctr} : iris_pos{ctr}(1) + iris_radius_internal{ctr}
            x = abs(pixw - iris_pos{ctr}(1));
            y = abs(pixh - iris_pos{ctr}(2));
            % Mask the pixels within the internal iris
            if sqrt(x^2 + y^2) < iris_radius_internal{ctr}
                mask{ctr}(pixh, pixw) = 0;
            end
        end
    end
    
    % Image cropping
    img{ctr} = img{ctr}(iris_pos{ctr}(2) - iris_hw{ctr}(4) : iris_pos{ctr}(2) + iris_hw{ctr}(2),...
        iris_pos{ctr}(1) - iris_hw{ctr}(1) : iris_pos{ctr}(1) + iris_hw{ctr}(3),:);
    
    % Mask (for lager pupil removing) cropping
    mask{ctr} = mask{ctr}(iris_pos{ctr}(2) - iris_hw{ctr}(4) : iris_pos{ctr}(2) + iris_hw{ctr}(2),...
        iris_pos{ctr}(1) - iris_hw{ctr}(1) : iris_pos{ctr}(1) + iris_hw{ctr}(3),:);
    
    % Mask (for morphological operations) cropping
    mask_morph{ctr} = mask_morph{ctr}(iris_pos{ctr}(2) - iris_hw{ctr}(4) : iris_pos{ctr}(2) + iris_hw{ctr}(2),...
        iris_pos{ctr}(1) - iris_hw{ctr}(1) : iris_pos{ctr}(1) + iris_hw{ctr}(3),:);
    
    img{ctr} = double(img{ctr});
    % remove the 2D trend after cropping (does not work very well)
    % img{ctr} = remove2Dtrend(img{ctr});
    
    % Resize images and masks to make all of them match when calculating
    img{ctr} = imresize(img{ctr}, [img_height, img_width]);
    mask{ctr} = imresize(mask{ctr}, [img_height, img_width]);
    mask_morph{ctr} = imresize(mask_morph{ctr}, [img_height, img_width]);
    
    % mask out the specular reflections
    img_spec = (img{ctr} > 240);
    [r,c,~] = find(img_spec);
    len = size(r);
    for idx = 1 : len(1)
        mask{ctr}(r(idx),c(idx)) = 0;
    end
    
    % Morphological Opening
    se_erode = ones(9,9);
    se_dilate = ones(2,2);
    mask_morph{ctr} = imerode(mask_morph{ctr}, se_erode);
    mask_morph{ctr} = imdilate(mask_morph{ctr}, se_dilate);
    % After morphological opening, some pixels are not binary
    % Need to do some thresholding
    mask_morph{ctr} = mask_morph{ctr} > 0.9;
    
    % Overlap of morphological opening and larger pupil removing
    mask{ctr} = mask{ctr}.*mask_morph{ctr};
end

% Overlap of masks from two images
mask_overlap = logical(mask{1}.*mask{2});

% BW area filter to only use the larges part (does not work very well)
% mask_overlap = bwareafilt(mask_overlap,1);

%% Light Parameters
% Tilt and Slant in degrees
% Given as argument of function (depends on left eye or right eye)

light_num = 2;
light = zeros(light_num,3);
for ctr = 1:light_num
    light(ctr,1) = sind(slant(ctr))*cosd(tilt(ctr));
    light(ctr,2) = sind(slant(ctr))*sind(tilt(ctr));
    light(ctr,3) = cosd(slant(ctr));
end

%% Compute Surface Normals (Photometric Stereo)
% Get intensity of each point
inten = zeros(img_height, img_width, img_num);
for ctr = 1:img_num
    img_cur = img{ctr};
    for pixh = 1:img_height
        for pixw = 1:img_width
            inten(pixh, pixw, ctr) = norm(double(img_cur(pixh, pixw, 1)));
        end
    end
end

% Calculate normal vectors
normal = zeros(img_height, img_width, 3);
for pixh = 1:img_height
    for pixw = 1:img_width
        % Reflected light intensities of curent pixel
        inten_cur = zeros(2,1);
        inten_cur(1) = inten(pixh,pixw,1);
        inten_cur(2) = inten(pixh,pixw,2);
        
        % basic method on Lambertian reflectance to calculate normal
        % normal_cur = pinv(light.'*light)*(light.'*inten_cur);
        normal_cur = pinv(light)*inten_cur;
        normal_cur = normal_cur/norm(normal_cur);
        normal(pixh, pixw, :) = normal_cur;
    end
end
normal(isnan(normal)) = 0;

%% Calculate Surface Normals

st = 4;
U = normal(1 : st : img_height, 1 : st : img_width, 1);
V = normal(1 : st : img_height, 1 : st : img_width, 2);
W = normal(1 : st : img_height, 1 : st : img_width, 3);
[X, Y] = meshgrid(1 : st : img_width, img_height : -st : 1);

%% Calculate the PAD score

% calculate average normal vector
normal_useful = mask_overlap .* normal;
normal_ave = mean(mean(normal_useful));
na(1) = normal_ave(1,1,1);
na(2) = normal_ave(1,1,2);
na(3) = normal_ave(1,1,3);
na = na/norm(na);
normal_ave(1,1,1) = na(1);
normal_ave(1,1,2) = na(2);
normal_ave(1,1,3) = na(3);

% Distances to the normal vector
diff = normal-normal_ave;
diff = sqrt(sum(diff.*diff,3));
norm_map = normal;
diff_reshape = reshape(diff(:,:),[],1);
mask_reshape = reshape(mask_overlap(:,:),[],1);
[row, col, v] = find(diff_reshape.*mask_reshape);

% PAD score: variation among distances
variation = var(v);

end